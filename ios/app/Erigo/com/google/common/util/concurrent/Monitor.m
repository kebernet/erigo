//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Volumes/Personal/Documents/raspi-config/client-framework/build/j2oSources/com/google/common/util/concurrent/Monitor.java
//

#include "J2ObjC_source.h"
#include "com/google/common/base/Preconditions.h"
#include "com/google/common/base/Throwables.h"
#include "com/google/common/util/concurrent/Monitor.h"
#include "java/lang/IllegalMonitorStateException.h"
#include "java/lang/InterruptedException.h"
#include "java/lang/Long.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/System.h"
#include "java/lang/Thread.h"
#include "java/util/concurrent/TimeUnit.h"
#include "java/util/concurrent/locks/Condition.h"
#include "java/util/concurrent/locks/ReentrantLock.h"
#include "java/util/function/BooleanSupplier.h"

@interface ComGoogleCommonUtilConcurrentMonitor () {
 @public
  jboolean fair_;
  JavaUtilConcurrentLocksReentrantLock *lock_;
  ComGoogleCommonUtilConcurrentMonitor_Guard *activeGuards_;
}

+ (jlong)toSafeNanosWithLong:(jlong)time
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

+ (jlong)initNanoTimeWithLong:(jlong)timeoutNanos OBJC_METHOD_FAMILY_NONE;

+ (jlong)remainingNanosWithLong:(jlong)startTime
                       withLong:(jlong)timeoutNanos;

- (void)signalNextWaiter;

- (jboolean)isSatisfiedWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard;

- (void)signalAllWaiters;

- (void)beginWaitingForWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard;

- (void)endWaitingForWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard;

- (void)awaitWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard
                                                withBoolean:(jboolean)signalBeforeWaiting;

- (void)awaitUninterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard
                                                               withBoolean:(jboolean)signalBeforeWaiting;

- (jboolean)awaitNanosWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard
                                                            withLong:(jlong)nanos
                                                         withBoolean:(jboolean)signalBeforeWaiting;

@end

J2OBJC_FIELD_SETTER(ComGoogleCommonUtilConcurrentMonitor, lock_, JavaUtilConcurrentLocksReentrantLock *)
J2OBJC_FIELD_SETTER(ComGoogleCommonUtilConcurrentMonitor, activeGuards_, ComGoogleCommonUtilConcurrentMonitor_Guard *)

__attribute__((unused)) static jlong ComGoogleCommonUtilConcurrentMonitor_toSafeNanosWithLong_withJavaUtilConcurrentTimeUnit_(jlong time, JavaUtilConcurrentTimeUnit *unit);

__attribute__((unused)) static jlong ComGoogleCommonUtilConcurrentMonitor_initNanoTimeWithLong_(jlong timeoutNanos);

__attribute__((unused)) static jlong ComGoogleCommonUtilConcurrentMonitor_remainingNanosWithLong_withLong_(jlong startTime, jlong timeoutNanos);

__attribute__((unused)) static void ComGoogleCommonUtilConcurrentMonitor_signalNextWaiter(ComGoogleCommonUtilConcurrentMonitor *self);

__attribute__((unused)) static jboolean ComGoogleCommonUtilConcurrentMonitor_isSatisfiedWithComGoogleCommonUtilConcurrentMonitor_Guard_(ComGoogleCommonUtilConcurrentMonitor *self, ComGoogleCommonUtilConcurrentMonitor_Guard *guard);

__attribute__((unused)) static void ComGoogleCommonUtilConcurrentMonitor_signalAllWaiters(ComGoogleCommonUtilConcurrentMonitor *self);

__attribute__((unused)) static void ComGoogleCommonUtilConcurrentMonitor_beginWaitingForWithComGoogleCommonUtilConcurrentMonitor_Guard_(ComGoogleCommonUtilConcurrentMonitor *self, ComGoogleCommonUtilConcurrentMonitor_Guard *guard);

__attribute__((unused)) static void ComGoogleCommonUtilConcurrentMonitor_endWaitingForWithComGoogleCommonUtilConcurrentMonitor_Guard_(ComGoogleCommonUtilConcurrentMonitor *self, ComGoogleCommonUtilConcurrentMonitor_Guard *guard);

__attribute__((unused)) static void ComGoogleCommonUtilConcurrentMonitor_awaitWithComGoogleCommonUtilConcurrentMonitor_Guard_withBoolean_(ComGoogleCommonUtilConcurrentMonitor *self, ComGoogleCommonUtilConcurrentMonitor_Guard *guard, jboolean signalBeforeWaiting);

__attribute__((unused)) static void ComGoogleCommonUtilConcurrentMonitor_awaitUninterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard_withBoolean_(ComGoogleCommonUtilConcurrentMonitor *self, ComGoogleCommonUtilConcurrentMonitor_Guard *guard, jboolean signalBeforeWaiting);

__attribute__((unused)) static jboolean ComGoogleCommonUtilConcurrentMonitor_awaitNanosWithComGoogleCommonUtilConcurrentMonitor_Guard_withLong_withBoolean_(ComGoogleCommonUtilConcurrentMonitor *self, ComGoogleCommonUtilConcurrentMonitor_Guard *guard, jlong nanos, jboolean signalBeforeWaiting);

@interface ComGoogleCommonUtilConcurrentMonitor_1 : ComGoogleCommonUtilConcurrentMonitor_Guard {
 @public
  id<JavaUtilFunctionBooleanSupplier> val$isSatisfied_;
}

- (instancetype)initWithJavaUtilFunctionBooleanSupplier:(id<JavaUtilFunctionBooleanSupplier>)capture$0
               withComGoogleCommonUtilConcurrentMonitor:(ComGoogleCommonUtilConcurrentMonitor *)monitor;

- (jboolean)isSatisfied;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentMonitor_1)

__attribute__((unused)) static void ComGoogleCommonUtilConcurrentMonitor_1_initWithJavaUtilFunctionBooleanSupplier_withComGoogleCommonUtilConcurrentMonitor_(ComGoogleCommonUtilConcurrentMonitor_1 *self, id<JavaUtilFunctionBooleanSupplier> capture$0, ComGoogleCommonUtilConcurrentMonitor *monitor);

__attribute__((unused)) static ComGoogleCommonUtilConcurrentMonitor_1 *new_ComGoogleCommonUtilConcurrentMonitor_1_initWithJavaUtilFunctionBooleanSupplier_withComGoogleCommonUtilConcurrentMonitor_(id<JavaUtilFunctionBooleanSupplier> capture$0, ComGoogleCommonUtilConcurrentMonitor *monitor) NS_RETURNS_RETAINED;

__attribute__((unused)) static ComGoogleCommonUtilConcurrentMonitor_1 *create_ComGoogleCommonUtilConcurrentMonitor_1_initWithJavaUtilFunctionBooleanSupplier_withComGoogleCommonUtilConcurrentMonitor_(id<JavaUtilFunctionBooleanSupplier> capture$0, ComGoogleCommonUtilConcurrentMonitor *monitor);

@implementation ComGoogleCommonUtilConcurrentMonitor

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  ComGoogleCommonUtilConcurrentMonitor_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (instancetype)initWithBoolean:(jboolean)fair {
  ComGoogleCommonUtilConcurrentMonitor_initWithBoolean_(self, fair);
  return self;
}

- (ComGoogleCommonUtilConcurrentMonitor_Guard *)newGuardWithJavaUtilFunctionBooleanSupplier:(id<JavaUtilFunctionBooleanSupplier>)isSatisfied {
  (void) ComGoogleCommonBasePreconditions_checkNotNullWithId_withId_(isSatisfied, @"isSatisfied");
  return new_ComGoogleCommonUtilConcurrentMonitor_1_initWithJavaUtilFunctionBooleanSupplier_withComGoogleCommonUtilConcurrentMonitor_(isSatisfied, self);
}

- (void)enter {
  [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock_)) lock];
}

- (void)enterInterruptibly {
  [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock_)) lockInterruptibly];
}

- (jboolean)enterWithLong:(jlong)time
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  jlong timeoutNanos = ComGoogleCommonUtilConcurrentMonitor_toSafeNanosWithLong_withJavaUtilConcurrentTimeUnit_(time, unit);
  JavaUtilConcurrentLocksReentrantLock *lock = self->lock_;
  if (!fair_ && [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock)) tryLock]) {
    return true;
  }
  jboolean interrupted = JavaLangThread_interrupted();
  @try {
    jlong startTime = JavaLangSystem_nanoTime();
    for (jlong remainingNanos = timeoutNanos; ; ) {
      @try {
        return [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock)) tryLockWithLong:remainingNanos withJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, NANOSECONDS)];
      }
      @catch (JavaLangInterruptedException *interrupt) {
        interrupted = true;
        remainingNanos = ComGoogleCommonUtilConcurrentMonitor_remainingNanosWithLong_withLong_(startTime, timeoutNanos);
      }
    }
  }
  @finally {
    if (interrupted) {
      [((JavaLangThread *) nil_chk(JavaLangThread_currentThread())) interrupt];
    }
  }
}

- (jboolean)enterInterruptiblyWithLong:(jlong)time
        withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  return [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock_)) tryLockWithLong:time withJavaUtilConcurrentTimeUnit:unit];
}

- (jboolean)tryEnter {
  return [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock_)) tryLock];
}

- (void)enterWhenWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard {
  if (((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(guard))->monitor_ != self) {
    @throw new_JavaLangIllegalMonitorStateException_init();
  }
  JavaUtilConcurrentLocksReentrantLock *lock = self->lock_;
  jboolean signalBeforeWaiting = [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock)) isHeldByCurrentThread];
  [lock lockInterruptibly];
  jboolean satisfied = false;
  @try {
    if (![guard isSatisfied]) {
      ComGoogleCommonUtilConcurrentMonitor_awaitWithComGoogleCommonUtilConcurrentMonitor_Guard_withBoolean_(self, guard, signalBeforeWaiting);
    }
    satisfied = true;
  }
  @finally {
    if (!satisfied) {
      [self leave];
    }
  }
}

- (void)enterWhenUninterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard {
  if (((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(guard))->monitor_ != self) {
    @throw new_JavaLangIllegalMonitorStateException_init();
  }
  JavaUtilConcurrentLocksReentrantLock *lock = self->lock_;
  jboolean signalBeforeWaiting = [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock)) isHeldByCurrentThread];
  [lock lock];
  jboolean satisfied = false;
  @try {
    if (![guard isSatisfied]) {
      ComGoogleCommonUtilConcurrentMonitor_awaitUninterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard_withBoolean_(self, guard, signalBeforeWaiting);
    }
    satisfied = true;
  }
  @finally {
    if (!satisfied) {
      [self leave];
    }
  }
}

- (jboolean)enterWhenWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard
                                                           withLong:(jlong)time
                                     withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  jlong timeoutNanos = ComGoogleCommonUtilConcurrentMonitor_toSafeNanosWithLong_withJavaUtilConcurrentTimeUnit_(time, unit);
  if (((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(guard))->monitor_ != self) {
    @throw new_JavaLangIllegalMonitorStateException_init();
  }
  JavaUtilConcurrentLocksReentrantLock *lock = self->lock_;
  jboolean reentrant = [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock)) isHeldByCurrentThread];
  jlong startTime = 0LL;
  {
    if (!fair_) {
      if (JavaLangThread_interrupted()) {
        @throw new_JavaLangInterruptedException_init();
      }
      if ([lock tryLock]) {
        goto break_locked;
      }
    }
    startTime = ComGoogleCommonUtilConcurrentMonitor_initNanoTimeWithLong_(timeoutNanos);
    if (![lock tryLockWithLong:time withJavaUtilConcurrentTimeUnit:unit]) {
      return false;
    }
  }
  break_locked: ;
  jboolean satisfied = false;
  jboolean threw = true;
  @try {
    satisfied = ([guard isSatisfied] || ComGoogleCommonUtilConcurrentMonitor_awaitNanosWithComGoogleCommonUtilConcurrentMonitor_Guard_withLong_withBoolean_(self, guard, (startTime == 0LL) ? timeoutNanos : ComGoogleCommonUtilConcurrentMonitor_remainingNanosWithLong_withLong_(startTime, timeoutNanos), reentrant));
    threw = false;
    return satisfied;
  }
  @finally {
    if (!satisfied) {
      @try {
        if (threw && !reentrant) {
          ComGoogleCommonUtilConcurrentMonitor_signalNextWaiter(self);
        }
      }
      @finally {
        [lock unlock];
      }
    }
  }
}

- (jboolean)enterWhenUninterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard
                                                                          withLong:(jlong)time
                                                    withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  jlong timeoutNanos = ComGoogleCommonUtilConcurrentMonitor_toSafeNanosWithLong_withJavaUtilConcurrentTimeUnit_(time, unit);
  if (((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(guard))->monitor_ != self) {
    @throw new_JavaLangIllegalMonitorStateException_init();
  }
  JavaUtilConcurrentLocksReentrantLock *lock = self->lock_;
  jlong startTime = 0LL;
  jboolean signalBeforeWaiting = [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock)) isHeldByCurrentThread];
  jboolean interrupted = JavaLangThread_interrupted();
  @try {
    if (fair_ || ![lock tryLock]) {
      startTime = ComGoogleCommonUtilConcurrentMonitor_initNanoTimeWithLong_(timeoutNanos);
      for (jlong remainingNanos = timeoutNanos; ; ) {
        @try {
          if ([lock tryLockWithLong:remainingNanos withJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, NANOSECONDS)]) {
            break;
          }
          else {
            return false;
          }
        }
        @catch (JavaLangInterruptedException *interrupt) {
          interrupted = true;
          remainingNanos = ComGoogleCommonUtilConcurrentMonitor_remainingNanosWithLong_withLong_(startTime, timeoutNanos);
        }
      }
    }
    jboolean satisfied = false;
    @try {
      while (true) {
        @try {
          if ([guard isSatisfied]) {
            satisfied = true;
          }
          else {
            jlong remainingNanos;
            if (startTime == 0LL) {
              startTime = ComGoogleCommonUtilConcurrentMonitor_initNanoTimeWithLong_(timeoutNanos);
              remainingNanos = timeoutNanos;
            }
            else {
              remainingNanos = ComGoogleCommonUtilConcurrentMonitor_remainingNanosWithLong_withLong_(startTime, timeoutNanos);
            }
            satisfied = ComGoogleCommonUtilConcurrentMonitor_awaitNanosWithComGoogleCommonUtilConcurrentMonitor_Guard_withLong_withBoolean_(self, guard, remainingNanos, signalBeforeWaiting);
          }
          return satisfied;
        }
        @catch (JavaLangInterruptedException *interrupt) {
          interrupted = true;
          signalBeforeWaiting = false;
        }
      }
    }
    @finally {
      if (!satisfied) {
        [lock unlock];
      }
    }
  }
  @finally {
    if (interrupted) {
      [((JavaLangThread *) nil_chk(JavaLangThread_currentThread())) interrupt];
    }
  }
}

- (jboolean)enterIfWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard {
  if (((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(guard))->monitor_ != self) {
    @throw new_JavaLangIllegalMonitorStateException_init();
  }
  JavaUtilConcurrentLocksReentrantLock *lock = self->lock_;
  [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock)) lock];
  jboolean satisfied = false;
  @try {
    return satisfied = [guard isSatisfied];
  }
  @finally {
    if (!satisfied) {
      [lock unlock];
    }
  }
}

- (jboolean)enterIfInterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard {
  if (((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(guard))->monitor_ != self) {
    @throw new_JavaLangIllegalMonitorStateException_init();
  }
  JavaUtilConcurrentLocksReentrantLock *lock = self->lock_;
  [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock)) lockInterruptibly];
  jboolean satisfied = false;
  @try {
    return satisfied = [guard isSatisfied];
  }
  @finally {
    if (!satisfied) {
      [lock unlock];
    }
  }
}

- (jboolean)enterIfWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard
                                                         withLong:(jlong)time
                                   withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  if (((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(guard))->monitor_ != self) {
    @throw new_JavaLangIllegalMonitorStateException_init();
  }
  if (![self enterWithLong:time withJavaUtilConcurrentTimeUnit:unit]) {
    return false;
  }
  jboolean satisfied = false;
  @try {
    return satisfied = [guard isSatisfied];
  }
  @finally {
    if (!satisfied) {
      [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock_)) unlock];
    }
  }
}

- (jboolean)enterIfInterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard
                                                                      withLong:(jlong)time
                                                withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  if (((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(guard))->monitor_ != self) {
    @throw new_JavaLangIllegalMonitorStateException_init();
  }
  JavaUtilConcurrentLocksReentrantLock *lock = self->lock_;
  if (![((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock)) tryLockWithLong:time withJavaUtilConcurrentTimeUnit:unit]) {
    return false;
  }
  jboolean satisfied = false;
  @try {
    return satisfied = [guard isSatisfied];
  }
  @finally {
    if (!satisfied) {
      [lock unlock];
    }
  }
}

- (jboolean)tryEnterIfWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard {
  if (((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(guard))->monitor_ != self) {
    @throw new_JavaLangIllegalMonitorStateException_init();
  }
  JavaUtilConcurrentLocksReentrantLock *lock = self->lock_;
  if (![((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock)) tryLock]) {
    return false;
  }
  jboolean satisfied = false;
  @try {
    return satisfied = [guard isSatisfied];
  }
  @finally {
    if (!satisfied) {
      [lock unlock];
    }
  }
}

- (void)waitForWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard {
  if (!((((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(guard))->monitor_ == self) & [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock_)) isHeldByCurrentThread])) {
    @throw new_JavaLangIllegalMonitorStateException_init();
  }
  if (![guard isSatisfied]) {
    ComGoogleCommonUtilConcurrentMonitor_awaitWithComGoogleCommonUtilConcurrentMonitor_Guard_withBoolean_(self, guard, true);
  }
}

- (void)waitForUninterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard {
  if (!((((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(guard))->monitor_ == self) & [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock_)) isHeldByCurrentThread])) {
    @throw new_JavaLangIllegalMonitorStateException_init();
  }
  if (![guard isSatisfied]) {
    ComGoogleCommonUtilConcurrentMonitor_awaitUninterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard_withBoolean_(self, guard, true);
  }
}

- (jboolean)waitForWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard
                                                         withLong:(jlong)time
                                   withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  jlong timeoutNanos = ComGoogleCommonUtilConcurrentMonitor_toSafeNanosWithLong_withJavaUtilConcurrentTimeUnit_(time, unit);
  if (!((((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(guard))->monitor_ == self) & [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock_)) isHeldByCurrentThread])) {
    @throw new_JavaLangIllegalMonitorStateException_init();
  }
  if ([guard isSatisfied]) {
    return true;
  }
  if (JavaLangThread_interrupted()) {
    @throw new_JavaLangInterruptedException_init();
  }
  return ComGoogleCommonUtilConcurrentMonitor_awaitNanosWithComGoogleCommonUtilConcurrentMonitor_Guard_withLong_withBoolean_(self, guard, timeoutNanos, true);
}

- (jboolean)waitForUninterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard
                                                                        withLong:(jlong)time
                                                  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  jlong timeoutNanos = ComGoogleCommonUtilConcurrentMonitor_toSafeNanosWithLong_withJavaUtilConcurrentTimeUnit_(time, unit);
  if (!((((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(guard))->monitor_ == self) & [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock_)) isHeldByCurrentThread])) {
    @throw new_JavaLangIllegalMonitorStateException_init();
  }
  if ([guard isSatisfied]) {
    return true;
  }
  jboolean signalBeforeWaiting = true;
  jlong startTime = ComGoogleCommonUtilConcurrentMonitor_initNanoTimeWithLong_(timeoutNanos);
  jboolean interrupted = JavaLangThread_interrupted();
  @try {
    for (jlong remainingNanos = timeoutNanos; ; ) {
      @try {
        return ComGoogleCommonUtilConcurrentMonitor_awaitNanosWithComGoogleCommonUtilConcurrentMonitor_Guard_withLong_withBoolean_(self, guard, remainingNanos, signalBeforeWaiting);
      }
      @catch (JavaLangInterruptedException *interrupt) {
        interrupted = true;
        if ([guard isSatisfied]) {
          return true;
        }
        signalBeforeWaiting = false;
        remainingNanos = ComGoogleCommonUtilConcurrentMonitor_remainingNanosWithLong_withLong_(startTime, timeoutNanos);
      }
    }
  }
  @finally {
    if (interrupted) {
      [((JavaLangThread *) nil_chk(JavaLangThread_currentThread())) interrupt];
    }
  }
}

- (void)leave {
  JavaUtilConcurrentLocksReentrantLock *lock = self->lock_;
  @try {
    if ([((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock)) getHoldCount] == 1) {
      ComGoogleCommonUtilConcurrentMonitor_signalNextWaiter(self);
    }
  }
  @finally {
    [lock unlock];
  }
}

- (jboolean)isFair {
  return fair_;
}

- (jboolean)isOccupied {
  return [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock_)) isLocked];
}

- (jboolean)isOccupiedByCurrentThread {
  return [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock_)) isHeldByCurrentThread];
}

- (jint)getOccupiedDepth {
  return [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock_)) getHoldCount];
}

- (jint)getQueueLength {
  return [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock_)) getQueueLength];
}

- (jboolean)hasQueuedThreads {
  return [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock_)) hasQueuedThreads];
}

- (jboolean)hasQueuedThreadWithJavaLangThread:(JavaLangThread *)thread {
  return [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock_)) hasQueuedThreadWithJavaLangThread:thread];
}

- (jboolean)hasWaitersWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard {
  return [self getWaitQueueLengthWithComGoogleCommonUtilConcurrentMonitor_Guard:guard] > 0;
}

- (jint)getWaitQueueLengthWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard {
  if (((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(guard))->monitor_ != self) {
    @throw new_JavaLangIllegalMonitorStateException_init();
  }
  [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(lock_)) lock];
  @try {
    return guard->waiterCount_;
  }
  @finally {
    [lock_ unlock];
  }
}

+ (jlong)toSafeNanosWithLong:(jlong)time
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  return ComGoogleCommonUtilConcurrentMonitor_toSafeNanosWithLong_withJavaUtilConcurrentTimeUnit_(time, unit);
}

+ (jlong)initNanoTimeWithLong:(jlong)timeoutNanos {
  return ComGoogleCommonUtilConcurrentMonitor_initNanoTimeWithLong_(timeoutNanos);
}

+ (jlong)remainingNanosWithLong:(jlong)startTime
                       withLong:(jlong)timeoutNanos {
  return ComGoogleCommonUtilConcurrentMonitor_remainingNanosWithLong_withLong_(startTime, timeoutNanos);
}

- (void)signalNextWaiter {
  ComGoogleCommonUtilConcurrentMonitor_signalNextWaiter(self);
}

- (jboolean)isSatisfiedWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard {
  return ComGoogleCommonUtilConcurrentMonitor_isSatisfiedWithComGoogleCommonUtilConcurrentMonitor_Guard_(self, guard);
}

- (void)signalAllWaiters {
  ComGoogleCommonUtilConcurrentMonitor_signalAllWaiters(self);
}

- (void)beginWaitingForWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard {
  ComGoogleCommonUtilConcurrentMonitor_beginWaitingForWithComGoogleCommonUtilConcurrentMonitor_Guard_(self, guard);
}

- (void)endWaitingForWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard {
  ComGoogleCommonUtilConcurrentMonitor_endWaitingForWithComGoogleCommonUtilConcurrentMonitor_Guard_(self, guard);
}

- (void)awaitWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard
                                                withBoolean:(jboolean)signalBeforeWaiting {
  ComGoogleCommonUtilConcurrentMonitor_awaitWithComGoogleCommonUtilConcurrentMonitor_Guard_withBoolean_(self, guard, signalBeforeWaiting);
}

- (void)awaitUninterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard
                                                               withBoolean:(jboolean)signalBeforeWaiting {
  ComGoogleCommonUtilConcurrentMonitor_awaitUninterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard_withBoolean_(self, guard, signalBeforeWaiting);
}

- (jboolean)awaitNanosWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard *)guard
                                                            withLong:(jlong)nanos
                                                         withBoolean:(jboolean)signalBeforeWaiting {
  return ComGoogleCommonUtilConcurrentMonitor_awaitNanosWithComGoogleCommonUtilConcurrentMonitor_Guard_withLong_withBoolean_(self, guard, nanos, signalBeforeWaiting);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "LComGoogleCommonUtilConcurrentMonitor_Guard;", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "Z", 0x1, 4, 5, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 6, 5, 3, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 7, 8, 3, -1, -1, -1 },
    { NULL, "V", 0x1, 9, 8, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 7, 10, 3, -1, -1, -1 },
    { NULL, "Z", 0x1, 9, 10, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 11, 8, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 12, 8, 3, -1, -1, -1 },
    { NULL, "Z", 0x1, 11, 10, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 12, 10, 3, -1, -1, -1 },
    { NULL, "Z", 0x1, 13, 8, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 14, 8, 3, -1, -1, -1 },
    { NULL, "V", 0x1, 15, 8, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 14, 10, 3, -1, -1, -1 },
    { NULL, "Z", 0x1, 15, 10, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 16, 17, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 18, 8, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 19, 8, -1, -1, -1, -1 },
    { NULL, "J", 0xa, 20, 5, -1, -1, -1, -1 },
    { NULL, "J", 0xa, 21, 22, -1, -1, -1, -1 },
    { NULL, "J", 0xa, 23, 24, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 25, 8, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 26, 8, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 27, 8, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 28, 29, 3, -1, -1, -1 },
    { NULL, "V", 0x2, 30, 29, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 31, 32, 3, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(initWithBoolean:);
  methods[2].selector = @selector(newGuardWithJavaUtilFunctionBooleanSupplier:);
  methods[3].selector = @selector(enter);
  methods[4].selector = @selector(enterInterruptibly);
  methods[5].selector = @selector(enterWithLong:withJavaUtilConcurrentTimeUnit:);
  methods[6].selector = @selector(enterInterruptiblyWithLong:withJavaUtilConcurrentTimeUnit:);
  methods[7].selector = @selector(tryEnter);
  methods[8].selector = @selector(enterWhenWithComGoogleCommonUtilConcurrentMonitor_Guard:);
  methods[9].selector = @selector(enterWhenUninterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard:);
  methods[10].selector = @selector(enterWhenWithComGoogleCommonUtilConcurrentMonitor_Guard:withLong:withJavaUtilConcurrentTimeUnit:);
  methods[11].selector = @selector(enterWhenUninterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard:withLong:withJavaUtilConcurrentTimeUnit:);
  methods[12].selector = @selector(enterIfWithComGoogleCommonUtilConcurrentMonitor_Guard:);
  methods[13].selector = @selector(enterIfInterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard:);
  methods[14].selector = @selector(enterIfWithComGoogleCommonUtilConcurrentMonitor_Guard:withLong:withJavaUtilConcurrentTimeUnit:);
  methods[15].selector = @selector(enterIfInterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard:withLong:withJavaUtilConcurrentTimeUnit:);
  methods[16].selector = @selector(tryEnterIfWithComGoogleCommonUtilConcurrentMonitor_Guard:);
  methods[17].selector = @selector(waitForWithComGoogleCommonUtilConcurrentMonitor_Guard:);
  methods[18].selector = @selector(waitForUninterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard:);
  methods[19].selector = @selector(waitForWithComGoogleCommonUtilConcurrentMonitor_Guard:withLong:withJavaUtilConcurrentTimeUnit:);
  methods[20].selector = @selector(waitForUninterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard:withLong:withJavaUtilConcurrentTimeUnit:);
  methods[21].selector = @selector(leave);
  methods[22].selector = @selector(isFair);
  methods[23].selector = @selector(isOccupied);
  methods[24].selector = @selector(isOccupiedByCurrentThread);
  methods[25].selector = @selector(getOccupiedDepth);
  methods[26].selector = @selector(getQueueLength);
  methods[27].selector = @selector(hasQueuedThreads);
  methods[28].selector = @selector(hasQueuedThreadWithJavaLangThread:);
  methods[29].selector = @selector(hasWaitersWithComGoogleCommonUtilConcurrentMonitor_Guard:);
  methods[30].selector = @selector(getWaitQueueLengthWithComGoogleCommonUtilConcurrentMonitor_Guard:);
  methods[31].selector = @selector(toSafeNanosWithLong:withJavaUtilConcurrentTimeUnit:);
  methods[32].selector = @selector(initNanoTimeWithLong:);
  methods[33].selector = @selector(remainingNanosWithLong:withLong:);
  methods[34].selector = @selector(signalNextWaiter);
  methods[35].selector = @selector(isSatisfiedWithComGoogleCommonUtilConcurrentMonitor_Guard:);
  methods[36].selector = @selector(signalAllWaiters);
  methods[37].selector = @selector(beginWaitingForWithComGoogleCommonUtilConcurrentMonitor_Guard:);
  methods[38].selector = @selector(endWaitingForWithComGoogleCommonUtilConcurrentMonitor_Guard:);
  methods[39].selector = @selector(awaitWithComGoogleCommonUtilConcurrentMonitor_Guard:withBoolean:);
  methods[40].selector = @selector(awaitUninterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard:withBoolean:);
  methods[41].selector = @selector(awaitNanosWithComGoogleCommonUtilConcurrentMonitor_Guard:withLong:withBoolean:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "fair_", "Z", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "lock_", "LJavaUtilConcurrentLocksReentrantLock;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "activeGuards_", "LComGoogleCommonUtilConcurrentMonitor_Guard;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "Z", "newGuard", "LJavaUtilFunctionBooleanSupplier;", "LJavaLangInterruptedException;", "enter", "JLJavaUtilConcurrentTimeUnit;", "enterInterruptibly", "enterWhen", "LComGoogleCommonUtilConcurrentMonitor_Guard;", "enterWhenUninterruptibly", "LComGoogleCommonUtilConcurrentMonitor_Guard;JLJavaUtilConcurrentTimeUnit;", "enterIf", "enterIfInterruptibly", "tryEnterIf", "waitFor", "waitForUninterruptibly", "hasQueuedThread", "LJavaLangThread;", "hasWaiters", "getWaitQueueLength", "toSafeNanos", "initNanoTime", "J", "remainingNanos", "JJ", "isSatisfied", "beginWaitingFor", "endWaitingFor", "await", "LComGoogleCommonUtilConcurrentMonitor_Guard;Z", "awaitUninterruptibly", "awaitNanos", "LComGoogleCommonUtilConcurrentMonitor_Guard;JZ" };
  static const J2ObjcClassInfo _ComGoogleCommonUtilConcurrentMonitor = { "Monitor", "com.google.common.util.concurrent", ptrTable, methods, fields, 7, 0x11, 42, 3, -1, 8, -1, -1, -1 };
  return &_ComGoogleCommonUtilConcurrentMonitor;
}

@end

void ComGoogleCommonUtilConcurrentMonitor_init(ComGoogleCommonUtilConcurrentMonitor *self) {
  ComGoogleCommonUtilConcurrentMonitor_initWithBoolean_(self, false);
}

ComGoogleCommonUtilConcurrentMonitor *new_ComGoogleCommonUtilConcurrentMonitor_init() {
  J2OBJC_NEW_IMPL(ComGoogleCommonUtilConcurrentMonitor, init)
}

ComGoogleCommonUtilConcurrentMonitor *create_ComGoogleCommonUtilConcurrentMonitor_init() {
  J2OBJC_CREATE_IMPL(ComGoogleCommonUtilConcurrentMonitor, init)
}

void ComGoogleCommonUtilConcurrentMonitor_initWithBoolean_(ComGoogleCommonUtilConcurrentMonitor *self, jboolean fair) {
  NSObject_init(self);
  self->activeGuards_ = nil;
  self->fair_ = fair;
  self->lock_ = new_JavaUtilConcurrentLocksReentrantLock_initWithBoolean_(fair);
}

ComGoogleCommonUtilConcurrentMonitor *new_ComGoogleCommonUtilConcurrentMonitor_initWithBoolean_(jboolean fair) {
  J2OBJC_NEW_IMPL(ComGoogleCommonUtilConcurrentMonitor, initWithBoolean_, fair)
}

ComGoogleCommonUtilConcurrentMonitor *create_ComGoogleCommonUtilConcurrentMonitor_initWithBoolean_(jboolean fair) {
  J2OBJC_CREATE_IMPL(ComGoogleCommonUtilConcurrentMonitor, initWithBoolean_, fair)
}

jlong ComGoogleCommonUtilConcurrentMonitor_toSafeNanosWithLong_withJavaUtilConcurrentTimeUnit_(jlong time, JavaUtilConcurrentTimeUnit *unit) {
  ComGoogleCommonUtilConcurrentMonitor_initialize();
  jlong timeoutNanos = [((JavaUtilConcurrentTimeUnit *) nil_chk(unit)) toNanosWithLong:time];
  return (timeoutNanos <= 0LL) ? 0LL : (timeoutNanos > (JavaLangLong_MAX_VALUE / 4) * 3) ? (JavaLangLong_MAX_VALUE / 4) * 3 : timeoutNanos;
}

jlong ComGoogleCommonUtilConcurrentMonitor_initNanoTimeWithLong_(jlong timeoutNanos) {
  ComGoogleCommonUtilConcurrentMonitor_initialize();
  if (timeoutNanos <= 0LL) {
    return 0LL;
  }
  else {
    jlong startTime = JavaLangSystem_nanoTime();
    return (startTime == 0LL) ? 1LL : startTime;
  }
}

jlong ComGoogleCommonUtilConcurrentMonitor_remainingNanosWithLong_withLong_(jlong startTime, jlong timeoutNanos) {
  ComGoogleCommonUtilConcurrentMonitor_initialize();
  return (timeoutNanos <= 0LL) ? 0LL : timeoutNanos - (JavaLangSystem_nanoTime() - startTime);
}

void ComGoogleCommonUtilConcurrentMonitor_signalNextWaiter(ComGoogleCommonUtilConcurrentMonitor *self) {
  for (ComGoogleCommonUtilConcurrentMonitor_Guard *guard = self->activeGuards_; guard != nil; guard = guard->next_) {
    if (ComGoogleCommonUtilConcurrentMonitor_isSatisfiedWithComGoogleCommonUtilConcurrentMonitor_Guard_(self, guard)) {
      [((id<JavaUtilConcurrentLocksCondition>) nil_chk(guard->condition_)) signal];
      break;
    }
  }
}

jboolean ComGoogleCommonUtilConcurrentMonitor_isSatisfiedWithComGoogleCommonUtilConcurrentMonitor_Guard_(ComGoogleCommonUtilConcurrentMonitor *self, ComGoogleCommonUtilConcurrentMonitor_Guard *guard) {
  @try {
    return [((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(guard)) isSatisfied];
  }
  @catch (NSException *throwable) {
    ComGoogleCommonUtilConcurrentMonitor_signalAllWaiters(self);
    @throw nil_chk(ComGoogleCommonBaseThrowables_propagateWithNSException_(throwable));
  }
}

void ComGoogleCommonUtilConcurrentMonitor_signalAllWaiters(ComGoogleCommonUtilConcurrentMonitor *self) {
  for (ComGoogleCommonUtilConcurrentMonitor_Guard *guard = self->activeGuards_; guard != nil; guard = guard->next_) {
    [((id<JavaUtilConcurrentLocksCondition>) nil_chk(guard->condition_)) signalAll];
  }
}

void ComGoogleCommonUtilConcurrentMonitor_beginWaitingForWithComGoogleCommonUtilConcurrentMonitor_Guard_(ComGoogleCommonUtilConcurrentMonitor *self, ComGoogleCommonUtilConcurrentMonitor_Guard *guard) {
  jint waiters = ((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(guard))->waiterCount_++;
  if (waiters == 0) {
    guard->next_ = self->activeGuards_;
    self->activeGuards_ = guard;
  }
}

void ComGoogleCommonUtilConcurrentMonitor_endWaitingForWithComGoogleCommonUtilConcurrentMonitor_Guard_(ComGoogleCommonUtilConcurrentMonitor *self, ComGoogleCommonUtilConcurrentMonitor_Guard *guard) {
  jint waiters = --((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(guard))->waiterCount_;
  if (waiters == 0) {
    for (ComGoogleCommonUtilConcurrentMonitor_Guard *p = self->activeGuards_, *pred = nil; ; pred = p, p = ((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(p))->next_) {
      if (p == guard) {
        if (pred == nil) {
          self->activeGuards_ = ((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(p))->next_;
        }
        else {
          pred->next_ = ((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(p))->next_;
        }
        p->next_ = nil;
        break;
      }
    }
  }
}

void ComGoogleCommonUtilConcurrentMonitor_awaitWithComGoogleCommonUtilConcurrentMonitor_Guard_withBoolean_(ComGoogleCommonUtilConcurrentMonitor *self, ComGoogleCommonUtilConcurrentMonitor_Guard *guard, jboolean signalBeforeWaiting) {
  if (signalBeforeWaiting) {
    ComGoogleCommonUtilConcurrentMonitor_signalNextWaiter(self);
  }
  ComGoogleCommonUtilConcurrentMonitor_beginWaitingForWithComGoogleCommonUtilConcurrentMonitor_Guard_(self, guard);
  @try {
    do {
      [((id<JavaUtilConcurrentLocksCondition>) nil_chk(((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(guard))->condition_)) await];
    }
    while (![guard isSatisfied]);
  }
  @finally {
    ComGoogleCommonUtilConcurrentMonitor_endWaitingForWithComGoogleCommonUtilConcurrentMonitor_Guard_(self, guard);
  }
}

void ComGoogleCommonUtilConcurrentMonitor_awaitUninterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard_withBoolean_(ComGoogleCommonUtilConcurrentMonitor *self, ComGoogleCommonUtilConcurrentMonitor_Guard *guard, jboolean signalBeforeWaiting) {
  if (signalBeforeWaiting) {
    ComGoogleCommonUtilConcurrentMonitor_signalNextWaiter(self);
  }
  ComGoogleCommonUtilConcurrentMonitor_beginWaitingForWithComGoogleCommonUtilConcurrentMonitor_Guard_(self, guard);
  @try {
    do {
      [((id<JavaUtilConcurrentLocksCondition>) nil_chk(((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(guard))->condition_)) awaitUninterruptibly];
    }
    while (![guard isSatisfied]);
  }
  @finally {
    ComGoogleCommonUtilConcurrentMonitor_endWaitingForWithComGoogleCommonUtilConcurrentMonitor_Guard_(self, guard);
  }
}

jboolean ComGoogleCommonUtilConcurrentMonitor_awaitNanosWithComGoogleCommonUtilConcurrentMonitor_Guard_withLong_withBoolean_(ComGoogleCommonUtilConcurrentMonitor *self, ComGoogleCommonUtilConcurrentMonitor_Guard *guard, jlong nanos, jboolean signalBeforeWaiting) {
  jboolean firstTime = true;
  @try {
    do {
      if (nanos <= 0LL) {
        return false;
      }
      if (firstTime) {
        if (signalBeforeWaiting) {
          ComGoogleCommonUtilConcurrentMonitor_signalNextWaiter(self);
        }
        ComGoogleCommonUtilConcurrentMonitor_beginWaitingForWithComGoogleCommonUtilConcurrentMonitor_Guard_(self, guard);
        firstTime = false;
      }
      nanos = [((id<JavaUtilConcurrentLocksCondition>) nil_chk(((ComGoogleCommonUtilConcurrentMonitor_Guard *) nil_chk(guard))->condition_)) awaitNanosWithLong:nanos];
    }
    while (![guard isSatisfied]);
    return true;
  }
  @finally {
    if (!firstTime) {
      ComGoogleCommonUtilConcurrentMonitor_endWaitingForWithComGoogleCommonUtilConcurrentMonitor_Guard_(self, guard);
    }
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ComGoogleCommonUtilConcurrentMonitor)

@implementation ComGoogleCommonUtilConcurrentMonitor_Guard

- (instancetype)initWithComGoogleCommonUtilConcurrentMonitor:(ComGoogleCommonUtilConcurrentMonitor *)monitor {
  ComGoogleCommonUtilConcurrentMonitor_Guard_initWithComGoogleCommonUtilConcurrentMonitor_(self, monitor);
  return self;
}

- (jboolean)isSatisfied {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (void)__javaClone:(ComGoogleCommonUtilConcurrentMonitor_Guard *)original {
  [super __javaClone:original];
  JreRelease(monitor_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x4, -1, 0, -1, -1, -1, -1 },
    { NULL, "Z", 0x401, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithComGoogleCommonUtilConcurrentMonitor:);
  methods[1].selector = @selector(isSatisfied);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "monitor_", "LComGoogleCommonUtilConcurrentMonitor;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "condition_", "LJavaUtilConcurrentLocksCondition;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "waiterCount_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "next_", "LComGoogleCommonUtilConcurrentMonitor_Guard;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LComGoogleCommonUtilConcurrentMonitor;" };
  static const J2ObjcClassInfo _ComGoogleCommonUtilConcurrentMonitor_Guard = { "Guard", "com.google.common.util.concurrent", ptrTable, methods, fields, 7, 0x409, 2, 4, 0, -1, -1, -1, -1 };
  return &_ComGoogleCommonUtilConcurrentMonitor_Guard;
}

@end

void ComGoogleCommonUtilConcurrentMonitor_Guard_initWithComGoogleCommonUtilConcurrentMonitor_(ComGoogleCommonUtilConcurrentMonitor_Guard *self, ComGoogleCommonUtilConcurrentMonitor *monitor) {
  NSObject_init(self);
  self->waiterCount_ = 0;
  self->monitor_ = ComGoogleCommonBasePreconditions_checkNotNullWithId_withId_(monitor, @"monitor");
  self->condition_ = [((JavaUtilConcurrentLocksReentrantLock *) nil_chk(((ComGoogleCommonUtilConcurrentMonitor *) nil_chk(monitor))->lock_)) newCondition];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ComGoogleCommonUtilConcurrentMonitor_Guard)

@implementation ComGoogleCommonUtilConcurrentMonitor_1

- (instancetype)initWithJavaUtilFunctionBooleanSupplier:(id<JavaUtilFunctionBooleanSupplier>)capture$0
               withComGoogleCommonUtilConcurrentMonitor:(ComGoogleCommonUtilConcurrentMonitor *)monitor {
  ComGoogleCommonUtilConcurrentMonitor_1_initWithJavaUtilFunctionBooleanSupplier_withComGoogleCommonUtilConcurrentMonitor_(self, capture$0, monitor);
  return self;
}

- (jboolean)isSatisfied {
  return [((id<JavaUtilFunctionBooleanSupplier>) nil_chk(val$isSatisfied_)) getAsBoolean];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaUtilFunctionBooleanSupplier:withComGoogleCommonUtilConcurrentMonitor:);
  methods[1].selector = @selector(isSatisfied);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "val$isSatisfied_", "LJavaUtilFunctionBooleanSupplier;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LComGoogleCommonUtilConcurrentMonitor;", "newGuardWithJavaUtilFunctionBooleanSupplier:" };
  static const J2ObjcClassInfo _ComGoogleCommonUtilConcurrentMonitor_1 = { "", "com.google.common.util.concurrent", ptrTable, methods, fields, 7, 0x8018, 2, 1, 0, -1, 1, -1, -1 };
  return &_ComGoogleCommonUtilConcurrentMonitor_1;
}

@end

void ComGoogleCommonUtilConcurrentMonitor_1_initWithJavaUtilFunctionBooleanSupplier_withComGoogleCommonUtilConcurrentMonitor_(ComGoogleCommonUtilConcurrentMonitor_1 *self, id<JavaUtilFunctionBooleanSupplier> capture$0, ComGoogleCommonUtilConcurrentMonitor *monitor) {
  self->val$isSatisfied_ = capture$0;
  ComGoogleCommonUtilConcurrentMonitor_Guard_initWithComGoogleCommonUtilConcurrentMonitor_(self, monitor);
}

ComGoogleCommonUtilConcurrentMonitor_1 *new_ComGoogleCommonUtilConcurrentMonitor_1_initWithJavaUtilFunctionBooleanSupplier_withComGoogleCommonUtilConcurrentMonitor_(id<JavaUtilFunctionBooleanSupplier> capture$0, ComGoogleCommonUtilConcurrentMonitor *monitor) {
  J2OBJC_NEW_IMPL(ComGoogleCommonUtilConcurrentMonitor_1, initWithJavaUtilFunctionBooleanSupplier_withComGoogleCommonUtilConcurrentMonitor_, capture$0, monitor)
}

ComGoogleCommonUtilConcurrentMonitor_1 *create_ComGoogleCommonUtilConcurrentMonitor_1_initWithJavaUtilFunctionBooleanSupplier_withComGoogleCommonUtilConcurrentMonitor_(id<JavaUtilFunctionBooleanSupplier> capture$0, ComGoogleCommonUtilConcurrentMonitor *monitor) {
  J2OBJC_CREATE_IMPL(ComGoogleCommonUtilConcurrentMonitor_1, initWithJavaUtilFunctionBooleanSupplier_withComGoogleCommonUtilConcurrentMonitor_, capture$0, monitor)
}
